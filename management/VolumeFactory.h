/// \file VolumeFactory.h
/// \author Johannes de Fine Licht (johannes.definelicht@cern.ch)

#ifndef VECGEOM_MANAGEMENT_VOLUMEFACTORY_H_
#define VECGEOM_MANAGEMENT_VOLUMEFACTORY_H_

#include "volumes/PlacedVolume.h"
#include "base/Transformation3D.h"
#include "volumes/LogicalVolume.h"

namespace vecgeom {
inline namespace VECGEOM_IMPL_NAMESPACE {

class VolumeFactory {

public:

  static VolumeFactory& Instance() {
    static VolumeFactory instance;
    return instance;
  }

  #ifndef VECGEOM_NVCC

  template<typename VolumeType>
#ifdef OFFLOAD_MODE
__attribute__ ((target(mic)))
#endif
  static VPlacedVolume* CreateByTransformation(
      LogicalVolume const *const logical_volume,
      Transformation3D const *const transformation,
      const TranslationCode trans_code, const RotationCode rot_code,
      VPlacedVolume *const placement = NULL);

  #else

  template<typename VolumeType>
  VECGEOM_CUDA_HEADER_DEVICE
  static VPlacedVolume* CreateByTransformation(
      LogicalVolume const *const logical_volume,
      Transformation3D const *const transformation,
      const TranslationCode trans_code, const RotationCode rot_code,
      const int id, VPlacedVolume *const placement = NULL);

  #endif

private:

  VolumeFactory() {}
  VolumeFactory(VolumeFactory const&);
  VolumeFactory& operator=(VolumeFactory const&);

};

template<typename VolumeType>
#ifdef VECGEOM_NVCC
__device__
#endif
VPlacedVolume* VolumeFactory::CreateByTransformation(
    LogicalVolume const *const logical_volume,
    Transformation3D const *const transformation,
    const TranslationCode trans_code, const RotationCode rot_code,
    #ifdef VECGEOM_NVCC
    const int id,
    #endif
    VPlacedVolume *const placement) {

  // Specialization on translation and rotation.
  // Script generated by ../scripts/generate_specializations.py
#include "TransformationSpecializations.icc"

}

} } // End global namespace

#endif // VECGEOM_MANAGEMENT_VOLUMEFACTORY_H_
